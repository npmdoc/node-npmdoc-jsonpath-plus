<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="https://github.com/s3u/JSONPath">jsonpath-plus (v0.16.0)</a>
</h1>
<h4>A JS implementation of JSONPath with some additional operators</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus">module jsonpath-plus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath-plus">
            function <span class="apidocSignatureSpan"></span>jsonpath-plus
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>eval
            <span class="apidocSignatureSpan">(obj, expr, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPathArray">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathArray
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPathString">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathString
            <span class="apidocSignatureSpan">(pathArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPointer">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPointer
            <span class="apidocSignatureSpan">(pointer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toString">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus.jsonpath">module jsonpath-plus.jsonpath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.jsonpath">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>eval
            <span class="apidocSignatureSpan">(obj, expr, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPathArray">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathArray
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPathString">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathString
            <span class="apidocSignatureSpan">(pathArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPointer">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPointer
            <span class="apidocSignatureSpan">(pointer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>cache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus.jsonpath.prototype">module jsonpath-plus.jsonpath.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_eval
            <span class="apidocSignatureSpan">(code, _v, _vname, path, parent, parentPropName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_getPreferredOutput
            <span class="apidocSignatureSpan">(ea)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_handleCallback
            <span class="apidocSignatureSpan">(fullRetObj, callback, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._slice">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_slice
            <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._trace">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_trace
            <span class="apidocSignatureSpan">(expr, val, path, parent, parentPropName, callback, literalPriority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._walk">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_walk
            <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>evaluate
            <span class="apidocSignatureSpan">(expr, json, callback, otherTypeCallback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus" id="apidoc.module.jsonpath-plus">module jsonpath-plus</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath-plus" id="apidoc.element.jsonpath-plus.jsonpath-plus">
        function <span class="apidocSignatureSpan"></span>jsonpath-plus
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === 'string') {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty('json') &amp;&amp; opts.hasOwnProperty('path');
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &amp;&amp; opts.resultType.toLowerCase()) || 'value';
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error('You must supply an otherTypeCallback callback option with the @other() operator.');
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== 'object') {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.eval" id="apidoc.element.jsonpath-plus.eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>eval
        <span class="apidocSignatureSpan">(obj, expr, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (obj, expr, opts) {
    return JSONPath(opts, expr, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the callback function being executed 0 to N times depending
on the number of independent items to be found in the result.
See the docs below for more on `JSONPath`'s available arguments.

The following format is now deprecated:

```js
  jsonPath.<span class="apidocCodeKeywordSpan">eval</span>(options, json, path);
```

## Properties

The properties that can be supplied on the options object or
evaluate method (as the first argument) include:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath" id="apidoc.element.jsonpath-plus.jsonpath">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === 'string') {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty('json') &amp;&amp; opts.hasOwnProperty('path');
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &amp;&amp; opts.resultType.toLowerCase()) || 'value';
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error('You must supply an otherTypeCallback callback option with the @other() operator.');
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== 'object') {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPathArray" id="apidoc.element.jsonpath-plus.toPathArray">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathArray
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathArray = function (expr) {
    var cache = JSONPath.cache;
    if (cache[expr]) {return cache[expr].concat();}
    var subx = [];
    var normalized = expr
                    // Properties
                    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/
g, ';$&amp;;')
                    // Parenthetical evaluations (filtering and otherwise), directly within brackets or single quotes
                    .replace(/[\['](\??\(.*?\))[\]']/g, function ($0, $1) {return '[#' + (subx.push($1) - 1) + ']';})
                    // Escape periods and tildes within properties
                    .replace(/\['([^'\]]*)'\]/g, function ($0, prop) {
                        return "['" + prop
                            .replace(/\./g, '%@%')
                            .replace(/~/g, '%%@@%%') +
                            "']";
                    })
                    // Properties operator
                    .replace(/~/g, ';~;')
                    // Split by property boundaries
                    .replace(/'?\.'?(?![^\[]*\])|\['?/g, ';')
                    // Reinsert periods within properties
                    .replace(/%@%/g, '.')
                    // Reinsert tildes within properties
                    .replace(/%%@@%%/g, '~')
                    // Parent
                    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {return ';' + ups.split('').join(';') + ';';})
                    // Descendents
                    .replace(/;;;|;;/g, ';..;')
                    // Remove trailing
                    .replace(/;$|'?\]|'$/g, '');

    var exprList = normalized.split(';').map(function (expr) {
        var match = expr.match(/#([0-9]+)/);
        return !match || !match[1] ? expr : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accept any of the other allowed instance properties (except
for `autostart` which would have no relevance here).

## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathArray</span>(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPathString" id="apidoc.element.jsonpath-plus.toPathString">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathString
        <span class="apidocSignatureSpan">(pathArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathString = function (pathArr) {
    var i, n, x = pathArr, p = '$';
    for (i = 1, n = x.length; i &lt; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += (/^[0-9*]+$/).test(x[i]) ? ('[' + x[i] + ']') : ("['" + x[i] + "']");
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.toPathArray(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathString</span>(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
- ***JSONPath.toPointer(pathAsArray)*** - Accepts a path array and
converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
The string will be in a form like: `'/aProperty/anotherProperty/0`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPointer" id="apidoc.element.jsonpath-plus.toPointer">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPointer
        <span class="apidocSignatureSpan">(pointer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPointer = function (pointer) {
    var i, n, x = pointer, p = '';
    for (i = 1, n = x.length; i &lt; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += '/' + x[i].toString()
                  .replace(/\~/g, '~0')
                  .replace(/\//g, '~1');
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  unnormalized path as string and converts to an array: for
  example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
  converts to a normalized path string. The string will be in a form
  like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
  constructions `~` and `^` and type operators like `@string()` are
  silently stripped.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPointer</span>(pathAsArray)*** - Accepts a path array and
  converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
  The string will be in a form like: `'/aProperty/anotherProperty/0`
  (with any `~` and `/` internal characters escaped as per the JSON
  Pointer spec). The JSONPath terminal constructions `~` and `^` and
  type operators like `@string()` are silently stripped.

# Syntax through examples
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toString" id="apidoc.element.jsonpath-plus.toString">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus.jsonpath" id="apidoc.module.jsonpath-plus.jsonpath">module jsonpath-plus.jsonpath</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.jsonpath" id="apidoc.element.jsonpath-plus.jsonpath.jsonpath">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === 'string') {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty('json') &amp;&amp; opts.hasOwnProperty('path');
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &amp;&amp; opts.resultType.toLowerCase()) || 'value';
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty('wrap') ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error('You must supply an otherTypeCallback callback option with the @other() operator.');
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== 'object') {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.eval" id="apidoc.element.jsonpath-plus.jsonpath.eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>eval
        <span class="apidocSignatureSpan">(obj, expr, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (obj, expr, opts) {
    return JSONPath(opts, expr, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the callback function being executed 0 to N times depending
on the number of independent items to be found in the result.
See the docs below for more on `JSONPath`'s available arguments.

The following format is now deprecated:

```js
  jsonPath.<span class="apidocCodeKeywordSpan">eval</span>(options, json, path);
```

## Properties

The properties that can be supplied on the options object or
evaluate method (as the first argument) include:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPathArray" id="apidoc.element.jsonpath-plus.jsonpath.toPathArray">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathArray
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathArray = function (expr) {
    var cache = JSONPath.cache;
    if (cache[expr]) {return cache[expr].concat();}
    var subx = [];
    var normalized = expr
                    // Properties
                    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/
g, ';$&amp;;')
                    // Parenthetical evaluations (filtering and otherwise), directly within brackets or single quotes
                    .replace(/[\['](\??\(.*?\))[\]']/g, function ($0, $1) {return '[#' + (subx.push($1) - 1) + ']';})
                    // Escape periods and tildes within properties
                    .replace(/\['([^'\]]*)'\]/g, function ($0, prop) {
                        return "['" + prop
                            .replace(/\./g, '%@%')
                            .replace(/~/g, '%%@@%%') +
                            "']";
                    })
                    // Properties operator
                    .replace(/~/g, ';~;')
                    // Split by property boundaries
                    .replace(/'?\.'?(?![^\[]*\])|\['?/g, ';')
                    // Reinsert periods within properties
                    .replace(/%@%/g, '.')
                    // Reinsert tildes within properties
                    .replace(/%%@@%%/g, '~')
                    // Parent
                    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {return ';' + ups.split('').join(';') + ';';})
                    // Descendents
                    .replace(/;;;|;;/g, ';..;')
                    // Remove trailing
                    .replace(/;$|'?\]|'$/g, '');

    var exprList = normalized.split(';').map(function (expr) {
        var match = expr.match(/#([0-9]+)/);
        return !match || !match[1] ? expr : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accept any of the other allowed instance properties (except
for `autostart` which would have no relevance here).

## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathArray</span>(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPathString" id="apidoc.element.jsonpath-plus.jsonpath.toPathString">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathString
        <span class="apidocSignatureSpan">(pathArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathString = function (pathArr) {
    var i, n, x = pathArr, p = '$';
    for (i = 1, n = x.length; i &lt; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += (/^[0-9*]+$/).test(x[i]) ? ('[' + x[i] + ']') : ("['" + x[i] + "']");
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.toPathArray(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathString</span>(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
- ***JSONPath.toPointer(pathAsArray)*** - Accepts a path array and
converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
The string will be in a form like: `'/aProperty/anotherProperty/0`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPointer" id="apidoc.element.jsonpath-plus.jsonpath.toPointer">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPointer
        <span class="apidocSignatureSpan">(pointer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPointer = function (pointer) {
    var i, n, x = pointer, p = '';
    for (i = 1, n = x.length; i &lt; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += '/' + x[i].toString()
                  .replace(/\~/g, '~0')
                  .replace(/\//g, '~1');
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  unnormalized path as string and converts to an array: for
  example, `['$', 'aProperty', 'anotherProperty']`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
  converts to a normalized path string. The string will be in a form
  like: `$['aProperty']['anotherProperty][0]`. The JSONPath terminal
  constructions `~` and `^` and type operators like `@string()` are
  silently stripped.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPointer</span>(pathAsArray)*** - Accepts a path array and
  converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
  The string will be in a form like: `'/aProperty/anotherProperty/0`
  (with any `~` and `/` internal characters escaped as per the JSON
  Pointer spec). The JSONPath terminal constructions `~` and `^` and
  type operators like `@string()` are silently stripped.

# Syntax through examples
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus.jsonpath.prototype" id="apidoc.module.jsonpath-plus.jsonpath.prototype">module jsonpath-plus.jsonpath.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._eval" id="apidoc.element.jsonpath-plus.jsonpath.prototype._eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_eval
        <span class="apidocSignatureSpan">(code, _v, _vname, path, parent, parentPropName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eval = function (code, _v, _vname, path, parent, parentPropName) {
    if (!this._obj || !_v) {return false;}
    if (code.includes('@parentProperty')) {
        this.currSandbox._$_parentProperty = parentPropName;
        code = code.replace(/@parentProperty/g, '_$_parentProperty');
    }
    if (code.includes('@parent')) {
        this.currSandbox._$_parent = parent;
        code = code.replace(/@parent/g, '_$_parent');
    }
    if (code.includes('@property')) {
        this.currSandbox._$_property = _vname;
        code = code.replace(/@property/g, '_$_property');
    }
    if (code.includes('@path')) {
        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
        code = code.replace(/@path/g, '_$_path');
    }
    if (code.match(/@([\.\s\)\[])/)) {
        this.currSandbox._$_v = _v;
        code = code.replace(/@([\.\s\)\[])/g, '_$_v$1');
    }
    try {
        return vm.runInNewContext(code, this.currSandbox);
    }
    catch (e) {
        console.log(e);
        throw new Error('jsonPath: ' + e.message + ': ' + code);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput" id="apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_getPreferredOutput
        <span class="apidocSignatureSpan">(ea)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getPreferredOutput = function (ea) {
    var resultType = this.currResultType;
    switch (resultType) {
    case 'all':
        ea.path = typeof ea.path === 'string' ? ea.path : JSONPath.toPathString(ea.path);
        return ea;
    case 'value': case 'parent': case 'parentProperty':
        return ea[resultType];
    case 'path':
        return JSONPath.toPathString(ea[resultType]);
    case 'pointer':
        return JSONPath.toPointer(ea.path);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback" id="apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_handleCallback
        <span class="apidocSignatureSpan">(fullRetObj, callback, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleCallback = function (fullRetObj, callback, type) {
    if (callback) {
        var preferredOutput = this._getPreferredOutput(fullRetObj);
        fullRetObj.path = typeof fullRetObj.path === 'string' ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
        callback(preferredOutput, type, fullRetObj);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._slice" id="apidoc.element.jsonpath-plus.jsonpath.prototype._slice">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_slice
        <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_slice = function (loc, expr, val, path, parent, parentPropName, callback) {
    if (!Array.isArray(val)) {return;}
    var i,
        len = val.length, parts = loc.split(':'),
        start = (parts[0] &amp;&amp; parseInt(parts[0], 10)) || 0,
        end = (parts[1] &amp;&amp; parseInt(parts[1], 10)) || len,
        step = (parts[2] &amp;&amp; parseInt(parts[2], 10)) || 1;
    start = (start &lt; 0) ? Math.max(0, start + len) : Math.min(len, start);
    end = (end &lt; 0) ? Math.max(0, end + len) : Math.min(len, end);
    var ret = [];
    for (i = start; i &lt; end; i += step) {
        var tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback);
        if (Array.isArray(tmp)) {
            tmp.forEach(function (t) {
                ret.push(t);
            });
        }
        else {
            ret.push(tmp);
        }
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._trace" id="apidoc.element.jsonpath-plus.jsonpath.prototype._trace">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_trace
        <span class="apidocSignatureSpan">(expr, val, path, parent, parentPropName, callback, literalPriority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trace = function (expr, val, path, parent, parentPropName, callback, literalPriority) {
    // No expr to follow? return path and value as the result of this trace branch
    var retObj, self = this;
    if (!expr.length) {
        retObj = {path: path, value: val, parent: parent, parentProperty: parentPropName};
        this._handleCallback(retObj, callback, 'value');
        return retObj;
    }

    var loc = expr[0], x = expr.slice(1);

    // We need to gather the return value of recursive trace calls in order to
    // do the parent sel computation.
    var ret = [];
    function retPush (elem) {
        ret.push(elem);
    }
    function addRet (elems) {
        if (Array.isArray(elems)) {
            elems.forEach(retPush);
        } else {
            ret.push(elems);
        }
    }

    if ((typeof loc !== 'string' || literalPriority) &amp;&amp; val &amp;&amp; Object.prototype.hasOwnProperty.call(val, loc)) { // simple case--
directly follow property
        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback));
    }
    else if (loc === '*') { // all child properties
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            addRet(self._trace(unshift(m, x), v, p, par, pr, cb, true));
        });
    }
    else if (loc === '..') { // all descendent parent properties
        addRet(this._trace(x, val, path, parent, parentPropName, callback)); // Check remaining expression with val's immediate
children
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            // We don't join m and x here because we only want parents, not scalar values
            if (typeof v[m] === 'object') { // Keep going with recursive descent on val's object children
                addRet(self._trace(unshift(l, x), v[m], push(p, m), v, m, cb));
            }
        });
    }
    // The parent sel computation is handled in the frame above using the
    // ancestor object of val
    else if (loc === '^') {
        // This is not a final endpoint, so we do not invoke the callback here
        this._hasParentSelector = true;
        return path.length ? {
            path: path.slice(0, -1),
            expr: x,
            isParentSelector: true
        } : [];
    }
    else if (loc === '~') { // property name
        retObj = {path: push(path, loc), value: parentPropName, parent: parent, parentProperty: null};
        this._handleCallback(retObj, callback, 'property');
        return retObj;
    }
    else if (loc === '$') { // root only
        addRet(this._trace(x, val, path, null, null, callback));
    }
    else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) { // [start:end:step]  Python slice syntax
        addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
    }
    else if (loc.indexOf('?(') === 0) { // [?(expr)] (filtering)
        if (this.currPreventEval) {
            throw new Error('Eval [?(expr)] prevented in JSONPath expression.');
        }
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            if (self._eval(l.replace(/^\?\((.*?)\)$/, '$1'), v[m], m, p, par, pr)) {
                addRet(self._trace(unshift(m, x), v, p, par, pr, cb));
            }
        });
    }
    else if (loc[0] === '(') { // [(expr)] (dynamic property/index)
        if (this.currPreventEval) {
            throw new Error('Eval [(expr)] prevented in JSONPath expression.');
        }
        // As this will resolve to a property name (but we don't know it yet), property and parent information is relative to the
 parent of the property to which this expression will resolve
        addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val
, path, parent, parentPropName, callback));
    }
    else if (loc[0] === '@') { // value type: @boolean(), etc.
        var addType = false;
        var valu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._walk" id="apidoc.element.jsonpath-plus.jsonpath.prototype._walk">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_walk
        <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {
    var i, n, m;
    if (Array.isArray(val)) {
        for (i = 0, n = val.length; i &lt; n; i++) {
            f(i, loc, expr, val, path, parent, parentPropName, callback);
        }
    }
    else if (typeof val === 'object') {
        for (m in val) {
            if (Object.prototype.hasOwnProperty.call(val, m)) {
                f(m, loc, expr, val, path, parent, parentPropName, callback);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate" id="apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>evaluate
        <span class="apidocSignatureSpan">(expr, json, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluate = function (expr, json, callback, otherTypeCallback) {
    var self = this,
        flatten = this.flatten,
        wrap = this.wrap,
        currParent = this.parent,
        currParentProperty = this.parentProperty;

    this.currResultType = this.resultType;
    this.currPreventEval = this.preventEval;
    this.currSandbox = this.sandbox;
    callback = callback || this.callback;
    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;

    json = json || this.json;
    expr = expr || this.path;
    if (expr &amp;&amp; typeof expr === 'object') {
        if (!expr.path) {
            throw new Error('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
        }
        json = expr.hasOwnProperty('json') ? expr.json : json;
        flatten = expr.hasOwnProperty('flatten') ? expr.flatten : flatten;
        this.currResultType = expr.hasOwnProperty('resultType') ? expr.resultType : this.currResultType;
        this.currSandbox = expr.hasOwnProperty('sandbox') ? expr.sandbox : this.currSandbox;
        wrap = expr.hasOwnProperty('wrap') ? expr.wrap : wrap;
        this.currPreventEval = expr.hasOwnProperty('preventEval') ? expr.preventEval : this.currPreventEval;
        callback = expr.hasOwnProperty('callback') ? expr.callback : callback;
        this.currOtherTypeCallback = expr.hasOwnProperty('otherTypeCallback') ? expr.otherTypeCallback : this.currOtherTypeCallback
;
        currParent = expr.hasOwnProperty('parent') ? expr.parent : currParent;
        currParentProperty = expr.hasOwnProperty('parentProperty') ? expr.parentProperty : currParentProperty;
        expr = expr.path;
    }
    currParent = currParent || null;
    currParentProperty = currParentProperty || null;

    if (Array.isArray(expr)) {
        expr = JSONPath.toPathString(expr);
    }
    if (!expr || !json || !allowedResultTypes.includes(this.currResultType)) {
        return;
    }
    this._obj = json;

    var exprList = JSONPath.toPathArray(expr);
    if (exprList[0] === '$' &amp;&amp; exprList.length &gt; 1) {exprList.shift();}
    this._hasParentSelector = null;
    var result = this._trace(exprList, json, ['$'], currParent, currParentProperty, callback);
    result = result.filter(function (ea) {return ea &amp;&amp; !ea.isParentSelector;});

    if (!result.length) {return wrap ? [] : undefined;}
    if (result.length === 1 &amp;&amp; !wrap &amp;&amp; !Array.isArray(result[0].value)) {
        return this._getPreferredOutput(result[0]);
    }
    return result.reduce(function (result, ea) {
        var valOrPath = self._getPreferredOutput(ea);
        if (flatten &amp;&amp; Array.isArray(valOrPath)) {
            result = result.concat(valOrPath);
        }
        else {
            result.push(valOrPath);
        }
        return result;
    }, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>