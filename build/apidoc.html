<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/s3u/JSONPath"

    >jsonpath-plus (v0.16.0)</a>
</h1>
<h4>A JS implementation of JSONPath with some additional operators</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus">module jsonpath-plus</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath-plus">
            function <span class="apidocSignatureSpan"></span>jsonpath-plus
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>eval
            <span class="apidocSignatureSpan">(obj, expr, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPathArray">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathArray
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPathString">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathString
            <span class="apidocSignatureSpan">(pathArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toPointer">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPointer
            <span class="apidocSignatureSpan">(pointer)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.toString">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus.jsonpath">module jsonpath-plus.jsonpath</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.jsonpath">
            function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
            <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>eval
            <span class="apidocSignatureSpan">(obj, expr, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPathArray">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathArray
            <span class="apidocSignatureSpan">(expr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPathString">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathString
            <span class="apidocSignatureSpan">(pathArr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.toPointer">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPointer
            <span class="apidocSignatureSpan">(pointer)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>cache</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.jsonpath-plus.jsonpath.prototype">module jsonpath-plus.jsonpath.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._eval">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_eval
            <span class="apidocSignatureSpan">(code, _v, _vname, path, parent, parentPropName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_getPreferredOutput
            <span class="apidocSignatureSpan">(ea)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_handleCallback
            <span class="apidocSignatureSpan">(fullRetObj, callback, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._slice">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_slice
            <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._trace">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_trace
            <span class="apidocSignatureSpan">(expr, val, path, parent, parentPropName, callback, literalPriority)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype._walk">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_walk
            <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback, f)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate">
            function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>evaluate
            <span class="apidocSignatureSpan">(expr, json, callback, otherTypeCallback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus" id="apidoc.module.jsonpath-plus">module jsonpath-plus</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath-plus" id="apidoc.element.jsonpath-plus.jsonpath-plus">
        function <span class="apidocSignatureSpan"></span>jsonpath-plus
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === &#x27;string&#x27;) {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty(&#x27;json&#x27;) &#x26;&#x26; opts.hasOwnProperty(&#x27;path&#x27;);
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &#x26;&#x26; opts.resultType.toLowerCase()) || &#x27;value&#x27;;
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty(&#x27;wrap&#x27;) ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error(&#x27;You must supply an otherTypeCallback callback option with the @other() operator.&#x27;);
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== &#x27;object&#x27;) {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.eval" id="apidoc.element.jsonpath-plus.eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>eval
        <span class="apidocSignatureSpan">(obj, expr, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (obj, expr, opts) {
    return JSONPath(opts, expr, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the callback function being executed 0 to N times depending
on the number of independent items to be found in the result.
See the docs below for more on `JSONPath`&#x27;s available arguments.

The following format is now deprecated:

```js
  jsonPath.<span class="apidocCodeKeywordSpan">eval</span>(options, json, path);
```

## Properties

The properties that can be supplied on the options object or
evaluate method (as the first argument) include:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath" id="apidoc.element.jsonpath-plus.jsonpath">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === &#x27;string&#x27;) {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty(&#x27;json&#x27;) &#x26;&#x26; opts.hasOwnProperty(&#x27;path&#x27;);
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &#x26;&#x26; opts.resultType.toLowerCase()) || &#x27;value&#x27;;
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty(&#x27;wrap&#x27;) ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error(&#x27;You must supply an otherTypeCallback callback option with the @other() operator.&#x27;);
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== &#x27;object&#x27;) {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPathArray" id="apidoc.element.jsonpath-plus.toPathArray">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathArray
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathArray = function (expr) {
    var cache = JSONPath.cache;
    if (cache[expr]) {return cache[expr].concat();}
    var subx = [];
    var normalized = expr
                    // Properties
                    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/
g, &#x27;;$&#x26;;&#x27;)
                    // Parenthetical evaluations (filtering and otherwise), directly within brackets or single quotes
                    .replace(/[\[&#x27;](\??\(.*?\))[\]&#x27;]/g, function ($0, $1) {return &#x27;[#&#x27; + (subx.push($1) - 1) + &#x27;]&#x27;;})
                    // Escape periods and tildes within properties
                    .replace(/\[&#x27;([^&#x27;\]]*)&#x27;\]/g, function ($0, prop) {
                        return &#x22;[&#x27;&#x22; + prop
                            .replace(/\./g, &#x27;%@%&#x27;)
                            .replace(/~/g, &#x27;%%@@%%&#x27;) +
                            &#x22;&#x27;]&#x22;;
                    })
                    // Properties operator
                    .replace(/~/g, &#x27;;~;&#x27;)
                    // Split by property boundaries
                    .replace(/&#x27;?\.&#x27;?(?![^\[]*\])|\[&#x27;?/g, &#x27;;&#x27;)
                    // Reinsert periods within properties
                    .replace(/%@%/g, &#x27;.&#x27;)
                    // Reinsert tildes within properties
                    .replace(/%%@@%%/g, &#x27;~&#x27;)
                    // Parent
                    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {return &#x27;;&#x27; + ups.split(&#x27;&#x27;).join(&#x27;;&#x27;) + &#x27;;&#x27;;})
                    // Descendents
                    .replace(/;;;|;;/g, &#x27;;..;&#x27;)
                    // Remove trailing
                    .replace(/;$|&#x27;?\]|&#x27;$/g, &#x27;&#x27;);

    var exprList = normalized.split(&#x27;;&#x27;).map(function (expr) {
        var match = expr.match(/#([0-9]+)/);
        return !match || !match[1] ? expr : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accept any of the other allowed instance properties (except
for `autostart` which would have no relevance here).

## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathArray</span>(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPathString" id="apidoc.element.jsonpath-plus.toPathString">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPathString
        <span class="apidocSignatureSpan">(pathArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathString = function (pathArr) {
    var i, n, x = pathArr, p = &#x27;$&#x27;;
    for (i = 1, n = x.length; i &#x3c; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += (/^[0-9*]+$/).test(x[i]) ? (&#x27;[&#x27; + x[i] + &#x27;]&#x27;) : (&#x22;[&#x27;&#x22; + x[i] + &#x22;&#x27;]&#x22;);
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.toPathArray(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathString</span>(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
- ***JSONPath.toPointer(pathAsArray)*** - Accepts a path array and
converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
The string will be in a form like: `&#x27;/aProperty/anotherProperty/0`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toPointer" id="apidoc.element.jsonpath-plus.toPointer">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toPointer
        <span class="apidocSignatureSpan">(pointer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPointer = function (pointer) {
    var i, n, x = pointer, p = &#x27;&#x27;;
    for (i = 1, n = x.length; i &#x3c; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += &#x27;/&#x27; + x[i].toString()
                  .replace(/\~/g, &#x27;~0&#x27;)
                  .replace(/\//g, &#x27;~1&#x27;);
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  unnormalized path as string and converts to an array: for
  example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
  converts to a normalized path string. The string will be in a form
  like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
  constructions `~` and `^` and type operators like `@string()` are
  silently stripped.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPointer</span>(pathAsArray)*** - Accepts a path array and
  converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
  The string will be in a form like: `&#x27;/aProperty/anotherProperty/0`
  (with any `~` and `/` internal characters escaped as per the JSON
  Pointer spec). The JSONPath terminal constructions `~` and `^` and
  type operators like `@string()` are silently stripped.

# Syntax through examples
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.toString" id="apidoc.element.jsonpath-plus.toString">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
    return text;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus.jsonpath" id="apidoc.module.jsonpath-plus.jsonpath">module jsonpath-plus.jsonpath</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.jsonpath" id="apidoc.element.jsonpath-plus.jsonpath.jsonpath">
        function <span class="apidocSignatureSpan">jsonpath-plus.</span>jsonpath
        <span class="apidocSignatureSpan">(opts, expr, obj, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
    if (!(this instanceof JSONPath)) {
        try {
            return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        }
        catch (e) {
            if (!e.avoidNew) {
                throw e;
            }
            return e.value;
        }
    }

    if (typeof opts === &#x27;string&#x27;) {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = {};
    }
    opts = opts || {};
    var objArgs = opts.hasOwnProperty(&#x27;json&#x27;) &#x26;&#x26; opts.hasOwnProperty(&#x27;path&#x27;);
    this.json = opts.json || obj;
    this.path = opts.path || expr;
    this.resultType = (opts.resultType &#x26;&#x26; opts.resultType.toLowerCase()) || &#x27;value&#x27;;
    this.flatten = opts.flatten || false;
    this.wrap = opts.hasOwnProperty(&#x27;wrap&#x27;) ? opts.wrap : true;
    this.sandbox = opts.sandbox || {};
    this.preventEval = opts.preventEval || false;
    this.parent = opts.parent || null;
    this.parentProperty = opts.parentProperty || null;
    this.callback = opts.callback || callback || null;
    this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function () {
        throw new Error(&#x27;You must supply an otherTypeCallback callback option with the @other() operator.&#x27;);
    };

    if (opts.autostart !== false) {
        var ret = this.evaluate({
            path: (objArgs ? opts.path : expr),
            json: (objArgs ? opts.json : obj)
        });
        if (!ret || typeof ret !== &#x27;object&#x27;) {
            throw new NewError(ret);
        }
        return ret;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.eval" id="apidoc.element.jsonpath-plus.jsonpath.eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>eval
        <span class="apidocSignatureSpan">(obj, expr, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eval = function (obj, expr, opts) {
    return JSONPath(opts, expr, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
the callback function being executed 0 to N times depending
on the number of independent items to be found in the result.
See the docs below for more on `JSONPath`&#x27;s available arguments.

The following format is now deprecated:

```js
  jsonPath.<span class="apidocCodeKeywordSpan">eval</span>(options, json, path);
```

## Properties

The properties that can be supplied on the options object or
evaluate method (as the first argument) include:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPathArray" id="apidoc.element.jsonpath-plus.jsonpath.toPathArray">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathArray
        <span class="apidocSignatureSpan">(expr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathArray = function (expr) {
    var cache = JSONPath.cache;
    if (cache[expr]) {return cache[expr].concat();}
    var subx = [];
    var normalized = expr
                    // Properties
                    .replace(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/
g, &#x27;;$&#x26;;&#x27;)
                    // Parenthetical evaluations (filtering and otherwise), directly within brackets or single quotes
                    .replace(/[\[&#x27;](\??\(.*?\))[\]&#x27;]/g, function ($0, $1) {return &#x27;[#&#x27; + (subx.push($1) - 1) + &#x27;]&#x27;;})
                    // Escape periods and tildes within properties
                    .replace(/\[&#x27;([^&#x27;\]]*)&#x27;\]/g, function ($0, prop) {
                        return &#x22;[&#x27;&#x22; + prop
                            .replace(/\./g, &#x27;%@%&#x27;)
                            .replace(/~/g, &#x27;%%@@%%&#x27;) +
                            &#x22;&#x27;]&#x22;;
                    })
                    // Properties operator
                    .replace(/~/g, &#x27;;~;&#x27;)
                    // Split by property boundaries
                    .replace(/&#x27;?\.&#x27;?(?![^\[]*\])|\[&#x27;?/g, &#x27;;&#x27;)
                    // Reinsert periods within properties
                    .replace(/%@%/g, &#x27;.&#x27;)
                    // Reinsert tildes within properties
                    .replace(/%%@@%%/g, &#x27;~&#x27;)
                    // Parent
                    .replace(/(?:;)?(\^+)(?:;)?/g, function ($0, ups) {return &#x27;;&#x27; + ups.split(&#x27;&#x27;).join(&#x27;;&#x27;) + &#x27;;&#x27;;})
                    // Descendents
                    .replace(/;;;|;;/g, &#x27;;..;&#x27;)
                    // Remove trailing
                    .replace(/;$|&#x27;?\]|&#x27;$/g, &#x27;&#x27;);

    var exprList = normalized.split(&#x27;;&#x27;).map(function (expr) {
        var match = expr.match(/#([0-9]+)/);
        return !match || !match[1] ? expr : subx[match[1]];
    });
    cache[expr] = exprList;
    return cache[expr];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
accept any of the other allowed instance properties (except
for `autostart` which would have no relevance here).

## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathArray</span>(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPathString" id="apidoc.element.jsonpath-plus.jsonpath.toPathString">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPathString
        <span class="apidocSignatureSpan">(pathArr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPathString = function (pathArr) {
    var i, n, x = pathArr, p = &#x27;$&#x27;;
    for (i = 1, n = x.length; i &#x3c; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += (/^[0-9*]+$/).test(x[i]) ? (&#x27;[&#x27; + x[i] + &#x27;]&#x27;) : (&#x22;[&#x27;&#x22; + x[i] + &#x22;&#x27;]&#x22;);
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
## Class properties and methods

- ***JSONPath.cache*** - Exposes the cache object for those who wish
to preserve and reuse it for optimization purposes.
- ***JSONPath.toPathArray(pathAsString)*** - Accepts a normalized or
unnormalized path as string and converts to an array: for
example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPathString</span>(pathAsArray)*** - Accepts a path array and
converts to a normalized path string. The string will be in a form
like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
constructions `~` and `^` and type operators like `@string()` are
silently stripped.
- ***JSONPath.toPointer(pathAsArray)*** - Accepts a path array and
converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
The string will be in a form like: `&#x27;/aProperty/anotherProperty/0`
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.toPointer" id="apidoc.element.jsonpath-plus.jsonpath.toPointer">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.</span>toPointer
        <span class="apidocSignatureSpan">(pointer)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toPointer = function (pointer) {
    var i, n, x = pointer, p = &#x27;&#x27;;
    for (i = 1, n = x.length; i &#x3c; n; i++) {
        if (!(/^(~|\^|@.*?\(\))$/).test(x[i])) {
            p += &#x27;/&#x27; + x[i].toString()
                  .replace(/\~/g, &#x27;~0&#x27;)
                  .replace(/\//g, &#x27;~1&#x27;);
        }
    }
    return p;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  unnormalized path as string and converts to an array: for
  example, `[&#x27;$&#x27;, &#x27;aProperty&#x27;, &#x27;anotherProperty&#x27;]`.
- ***JSONPath.toPathString(pathAsArray)*** - Accepts a path array and
  converts to a normalized path string. The string will be in a form
  like: `$[&#x27;aProperty&#x27;][&#x27;anotherProperty][0]`. The JSONPath terminal
  constructions `~` and `^` and type operators like `@string()` are
  silently stripped.
- ***JSONPath.<span class="apidocCodeKeywordSpan">toPointer</span>(pathAsArray)*** - Accepts a path array and
  converts to a [JSON Pointer](http://www.rfc-base.org/txt/rfc-6901.txt).
  The string will be in a form like: `&#x27;/aProperty/anotherProperty/0`
  (with any `~` and `/` internal characters escaped as per the JSON
  Pointer spec). The JSONPath terminal constructions `~` and `^` and
  type operators like `@string()` are silently stripped.

# Syntax through examples
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.jsonpath-plus.jsonpath.prototype" id="apidoc.module.jsonpath-plus.jsonpath.prototype">module jsonpath-plus.jsonpath.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._eval" id="apidoc.element.jsonpath-plus.jsonpath.prototype._eval">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_eval
        <span class="apidocSignatureSpan">(code, _v, _vname, path, parent, parentPropName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_eval = function (code, _v, _vname, path, parent, parentPropName) {
    if (!this._obj || !_v) {return false;}
    if (code.includes(&#x27;@parentProperty&#x27;)) {
        this.currSandbox._$_parentProperty = parentPropName;
        code = code.replace(/@parentProperty/g, &#x27;_$_parentProperty&#x27;);
    }
    if (code.includes(&#x27;@parent&#x27;)) {
        this.currSandbox._$_parent = parent;
        code = code.replace(/@parent/g, &#x27;_$_parent&#x27;);
    }
    if (code.includes(&#x27;@property&#x27;)) {
        this.currSandbox._$_property = _vname;
        code = code.replace(/@property/g, &#x27;_$_property&#x27;);
    }
    if (code.includes(&#x27;@path&#x27;)) {
        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
        code = code.replace(/@path/g, &#x27;_$_path&#x27;);
    }
    if (code.match(/@([\.\s\)\[])/)) {
        this.currSandbox._$_v = _v;
        code = code.replace(/@([\.\s\)\[])/g, &#x27;_$_v$1&#x27;);
    }
    try {
        return vm.runInNewContext(code, this.currSandbox);
    }
    catch (e) {
        console.log(e);
        throw new Error(&#x27;jsonPath: &#x27; + e.message + &#x27;: &#x27; + code);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput" id="apidoc.element.jsonpath-plus.jsonpath.prototype._getPreferredOutput">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_getPreferredOutput
        <span class="apidocSignatureSpan">(ea)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getPreferredOutput = function (ea) {
    var resultType = this.currResultType;
    switch (resultType) {
    case &#x27;all&#x27;:
        ea.path = typeof ea.path === &#x27;string&#x27; ? ea.path : JSONPath.toPathString(ea.path);
        return ea;
    case &#x27;value&#x27;: case &#x27;parent&#x27;: case &#x27;parentProperty&#x27;:
        return ea[resultType];
    case &#x27;path&#x27;:
        return JSONPath.toPathString(ea[resultType]);
    case &#x27;pointer&#x27;:
        return JSONPath.toPointer(ea.path);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback" id="apidoc.element.jsonpath-plus.jsonpath.prototype._handleCallback">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_handleCallback
        <span class="apidocSignatureSpan">(fullRetObj, callback, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_handleCallback = function (fullRetObj, callback, type) {
    if (callback) {
        var preferredOutput = this._getPreferredOutput(fullRetObj);
        fullRetObj.path = typeof fullRetObj.path === &#x27;string&#x27; ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
        callback(preferredOutput, type, fullRetObj);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._slice" id="apidoc.element.jsonpath-plus.jsonpath.prototype._slice">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_slice
        <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_slice = function (loc, expr, val, path, parent, parentPropName, callback) {
    if (!Array.isArray(val)) {return;}
    var i,
        len = val.length, parts = loc.split(&#x27;:&#x27;),
        start = (parts[0] &#x26;&#x26; parseInt(parts[0], 10)) || 0,
        end = (parts[1] &#x26;&#x26; parseInt(parts[1], 10)) || len,
        step = (parts[2] &#x26;&#x26; parseInt(parts[2], 10)) || 1;
    start = (start &#x3c; 0) ? Math.max(0, start + len) : Math.min(len, start);
    end = (end &#x3c; 0) ? Math.max(0, end + len) : Math.min(len, end);
    var ret = [];
    for (i = start; i &#x3c; end; i += step) {
        var tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback);
        if (Array.isArray(tmp)) {
            tmp.forEach(function (t) {
                ret.push(t);
            });
        }
        else {
            ret.push(tmp);
        }
    }
    return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._trace" id="apidoc.element.jsonpath-plus.jsonpath.prototype._trace">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_trace
        <span class="apidocSignatureSpan">(expr, val, path, parent, parentPropName, callback, literalPriority)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_trace = function (expr, val, path, parent, parentPropName, callback, literalPriority) {
    // No expr to follow? return path and value as the result of this trace branch
    var retObj, self = this;
    if (!expr.length) {
        retObj = {path: path, value: val, parent: parent, parentProperty: parentPropName};
        this._handleCallback(retObj, callback, &#x27;value&#x27;);
        return retObj;
    }

    var loc = expr[0], x = expr.slice(1);

    // We need to gather the return value of recursive trace calls in order to
    // do the parent sel computation.
    var ret = [];
    function retPush (elem) {
        ret.push(elem);
    }
    function addRet (elems) {
        if (Array.isArray(elems)) {
            elems.forEach(retPush);
        } else {
            ret.push(elems);
        }
    }

    if ((typeof loc !== &#x27;string&#x27; || literalPriority) &#x26;&#x26; val &#x26;&#x26; Object.prototype.hasOwnProperty.call(val, loc)) { // simple case--
directly follow property
        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback));
    }
    else if (loc === &#x27;*&#x27;) { // all child properties
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            addRet(self._trace(unshift(m, x), v, p, par, pr, cb, true));
        });
    }
    else if (loc === &#x27;..&#x27;) { // all descendent parent properties
        addRet(this._trace(x, val, path, parent, parentPropName, callback)); // Check remaining expression with val&#x27;s immediate
children
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            // We don&#x27;t join m and x here because we only want parents, not scalar values
            if (typeof v[m] === &#x27;object&#x27;) { // Keep going with recursive descent on val&#x27;s object children
                addRet(self._trace(unshift(l, x), v[m], push(p, m), v, m, cb));
            }
        });
    }
    // The parent sel computation is handled in the frame above using the
    // ancestor object of val
    else if (loc === &#x27;^&#x27;) {
        // This is not a final endpoint, so we do not invoke the callback here
        this._hasParentSelector = true;
        return path.length ? {
            path: path.slice(0, -1),
            expr: x,
            isParentSelector: true
        } : [];
    }
    else if (loc === &#x27;~&#x27;) { // property name
        retObj = {path: push(path, loc), value: parentPropName, parent: parent, parentProperty: null};
        this._handleCallback(retObj, callback, &#x27;property&#x27;);
        return retObj;
    }
    else if (loc === &#x27;$&#x27;) { // root only
        addRet(this._trace(x, val, path, null, null, callback));
    }
    else if (/^(-?[0-9]*):(-?[0-9]*):?([0-9]*)$/.test(loc)) { // [start:end:step]  Python slice syntax
        addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
    }
    else if (loc.indexOf(&#x27;?(&#x27;) === 0) { // [?(expr)] (filtering)
        if (this.currPreventEval) {
            throw new Error(&#x27;Eval [?(expr)] prevented in JSONPath expression.&#x27;);
        }
        this._walk(loc, x, val, path, parent, parentPropName, callback, function (m, l, x, v, p, par, pr, cb) {
            if (self._eval(l.replace(/^\?\((.*?)\)$/, &#x27;$1&#x27;), v[m], m, p, par, pr)) {
                addRet(self._trace(unshift(m, x), v, p, par, pr, cb));
            }
        });
    }
    else if (loc[0] === &#x27;(&#x27;) { // [(expr)] (dynamic property/index)
        if (this.currPreventEval) {
            throw new Error(&#x27;Eval [(expr)] prevented in JSONPath expression.&#x27;);
        }
        // As this will resolve to a property name (but we don&#x27;t know it yet), property and parent information is relative to the
 parent of the property to which this expression will resolve
        addRet(this._trace(unshift(this._eval(loc, val, path[path.length - 1], path.slice(0, -1), parent, parentPropName), x), val
, path, parent, parentPropName, callback));
    }
    else if (loc[0] === &#x27;@&#x27;) { // value type: @boolean(), etc.
        var addType = false;
        var valu ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype._walk" id="apidoc.element.jsonpath-plus.jsonpath.prototype._walk">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>_walk
        <span class="apidocSignatureSpan">(loc, expr, val, path, parent, parentPropName, callback, f)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_walk = function (loc, expr, val, path, parent, parentPropName, callback, f) {
    var i, n, m;
    if (Array.isArray(val)) {
        for (i = 0, n = val.length; i &#x3c; n; i++) {
            f(i, loc, expr, val, path, parent, parentPropName, callback);
        }
    }
    else if (typeof val === &#x27;object&#x27;) {
        for (m in val) {
            if (Object.prototype.hasOwnProperty.call(val, m)) {
                f(m, loc, expr, val, path, parent, parentPropName, callback);
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate" id="apidoc.element.jsonpath-plus.jsonpath.prototype.evaluate">
        function <span class="apidocSignatureSpan">jsonpath-plus.jsonpath.prototype.</span>evaluate
        <span class="apidocSignatureSpan">(expr, json, callback, otherTypeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluate = function (expr, json, callback, otherTypeCallback) {
    var self = this,
        flatten = this.flatten,
        wrap = this.wrap,
        currParent = this.parent,
        currParentProperty = this.parentProperty;

    this.currResultType = this.resultType;
    this.currPreventEval = this.preventEval;
    this.currSandbox = this.sandbox;
    callback = callback || this.callback;
    this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;

    json = json || this.json;
    expr = expr || this.path;
    if (expr &#x26;&#x26; typeof expr === &#x27;object&#x27;) {
        if (!expr.path) {
            throw new Error(&#x27;You must supply a &#x22;path&#x22; property when providing an object argument to JSONPath.evaluate().&#x27;);
        }
        json = expr.hasOwnProperty(&#x27;json&#x27;) ? expr.json : json;
        flatten = expr.hasOwnProperty(&#x27;flatten&#x27;) ? expr.flatten : flatten;
        this.currResultType = expr.hasOwnProperty(&#x27;resultType&#x27;) ? expr.resultType : this.currResultType;
        this.currSandbox = expr.hasOwnProperty(&#x27;sandbox&#x27;) ? expr.sandbox : this.currSandbox;
        wrap = expr.hasOwnProperty(&#x27;wrap&#x27;) ? expr.wrap : wrap;
        this.currPreventEval = expr.hasOwnProperty(&#x27;preventEval&#x27;) ? expr.preventEval : this.currPreventEval;
        callback = expr.hasOwnProperty(&#x27;callback&#x27;) ? expr.callback : callback;
        this.currOtherTypeCallback = expr.hasOwnProperty(&#x27;otherTypeCallback&#x27;) ? expr.otherTypeCallback : this.currOtherTypeCallback
;
        currParent = expr.hasOwnProperty(&#x27;parent&#x27;) ? expr.parent : currParent;
        currParentProperty = expr.hasOwnProperty(&#x27;parentProperty&#x27;) ? expr.parentProperty : currParentProperty;
        expr = expr.path;
    }
    currParent = currParent || null;
    currParentProperty = currParentProperty || null;

    if (Array.isArray(expr)) {
        expr = JSONPath.toPathString(expr);
    }
    if (!expr || !json || !allowedResultTypes.includes(this.currResultType)) {
        return;
    }
    this._obj = json;

    var exprList = JSONPath.toPathArray(expr);
    if (exprList[0] === &#x27;$&#x27; &#x26;&#x26; exprList.length &#x3e; 1) {exprList.shift();}
    this._hasParentSelector = null;
    var result = this._trace(exprList, json, [&#x27;$&#x27;], currParent, currParentProperty, callback);
    result = result.filter(function (ea) {return ea &#x26;&#x26; !ea.isParentSelector;});

    if (!result.length) {return wrap ? [] : undefined;}
    if (result.length === 1 &#x26;&#x26; !wrap &#x26;&#x26; !Array.isArray(result[0].value)) {
        return this._getPreferredOutput(result[0]);
    }
    return result.reduce(function (result, ea) {
        var valOrPath = self._getPreferredOutput(ea);
        if (flatten &#x26;&#x26; Array.isArray(valOrPath)) {
            result = result.concat(valOrPath);
        }
        else {
            result.push(valOrPath);
        }
        return result;
    }, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
